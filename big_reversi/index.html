<!doctype html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>å·¨å¤§ã‚ªã‚»ãƒ­ï½œ32Ã—32ãƒã‚¹ã®ç›¤é¢ã§éŠã¶</title>
<meta name="description" content="å·¨å¤§ãªã‚ªã‚»ãƒ­ç›¤ã§ã®ã‚²ãƒ¼ãƒ ã‚’ç„¡æ–™ã§éŠã¹ã‚‹Webã‚¢ãƒ—ãƒªã€‚é€šå¸¸ã®8Ã—8ã‚’è¶…ãˆã‚‹32Ã—32ãƒã‚¹ã®è¶…å·¨å¤§ç›¤é¢ã§ã€AIå¯¾æˆ¦ãƒ»å¯¾äººæˆ¦ãŒæ¥½ã—ã‚ã¾ã™ã€‚ãƒ–ãƒ©ã‚¦ã‚¶ã§ä»Šã™ããƒ—ãƒ¬ã‚¤ï¼" />
<meta name="author" content="Yuki Lab" />
<link rel="canonical" href="https://yuki-lab.com/big_reversi/" />

<!-- Open Graph -->
<meta property="og:type" content="website" />
<meta property="og:title" content="å·¨å¤§ãƒªãƒãƒ¼ã‚·ï½œ32Ã—32ãƒã‚¹ã®å·¨å¤§ã‚ªã‚»ãƒ­" />
<meta property="og:description" content="å·¨å¤§ãªã‚ªã‚»ãƒ­ï¼ˆãƒªãƒãƒ¼ã‚·ï¼‰ã‚’ç„¡æ–™ã§éŠã¹ã‚‹Webã‚¢ãƒ—ãƒªã€‚é€šå¸¸ã®8Ã—8ã‚’è¶…ãˆã‚‹32Ã—32ãƒã‚¹ã®è¶…å·¨å¤§ç›¤é¢ã§ã€AIå¯¾æˆ¦ãƒ»å¯¾äººæˆ¦ãŒæ¥½ã—ã‚ã¾ã™ã€‚ä»Šã™ããƒ—ãƒ¬ã‚¤ï¼" />
<meta property="og:url" content="https://yuki-lab.com/big_reversi/" />
<meta property="og:site_name" content="Yuki Lab" />
<meta property="og:locale" content="ja_JP" />

<!-- Twitter Card -->
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="å·¨å¤§ãƒªãƒãƒ¼ã‚· - 32Ã—32ãƒã‚¹ã®å·¨å¤§ãªã‚ªã‚»ãƒ­ã‚²ãƒ¼ãƒ " />
<meta name="twitter:description" content="32Ã—32ãƒã‚¹ã®å·¨å¤§ãªãƒªãƒãƒ¼ã‚·ï¼ˆã‚ªã‚»ãƒ­ï¼‰ã‚’ãƒ–ãƒ©ã‚¦ã‚¶ã§ç„¡æ–™ãƒ—ãƒ¬ã‚¤ã€‚AIå¯¾æˆ¦ãƒ»å¯¾äººæˆ¦å¯¾å¿œï¼" />

<!-- Favicon -->
<link rel="apple-touch-icon" type="image/png" href="../image/icon/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" sizes="16x16" href="../image/icon/icon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../image/icon/icon-32x32.png">
<link rel="icon" type="image/png" sizes="48x48" href="../image/icon/icon-48x48.png">

<style>
:root {
  --bg-deep: #0b1e10;
  --bg-mid: #132a18;
  --panel-bg: #1a2e1f;
  --panel-border: rgba(255, 255, 255, 0.08);
  --board: #0e7a1a;
  --board-dark: #0a6414;
  --line: #0a6414;
  --text: #e8f0e6;
  --text-dim: rgba(232, 240, 230, 0.55);
  --accent: #36c644;
  --accent-dim: rgba(74, 222, 128, 0.15);
  --stone-white-a: #fff;
  --stone-white-b: #b3b3b3;
  --last-move: #ef4444;
  --star: rgba(0, 0, 0, 0.5);
}

* { box-sizing: border-box; margin: 0; }

html, body {
  height: 105%;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Hiragino Sans', 'Noto Sans JP', sans-serif;
  color: var(--text);
  background: var(--bg-deep);
  background-image:
    radial-gradient(ellipse at 20% 0%, rgba(30, 80, 40, 0.5) 0%, transparent 60%),
    radial-gradient(ellipse at 80% 100%, rgba(20, 60, 30, 0.3) 0%, transparent 50%);
}

/* â”€â”€ Layout â”€â”€ */
.app {
  min-height: 100dvh;
  max-width: 960px;
  margin: 0 auto;
  padding: 10px 12px 12px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

/* â”€â”€ Top Panel â”€â”€ */
.top-panel {
  background: var(--panel-bg);
  border: 1px solid var(--panel-border);
  border-radius: 14px;
  padding: 12px 14px;
  box-shadow:
    0 1px 0 rgba(255,255,255,0.04) inset,
    0 8px 24px rgba(0, 0, 0, 0.35);
}

.title-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  flex-wrap: wrap;
}

.title {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Hiragino Sans', 'Noto Sans JP', sans-serif;
  font-size: clamp(1.1rem, 1.6vw + 0.5rem, 1.5rem);
  font-weight: 400;
  letter-spacing: 0.02em;
  color: var(--text);
}

/* â”€â”€ Tabs & Pills â”€â”€ */
.mode-tabs,
.level-tabs {
  display: inline-flex;
  background: rgba(255, 255, 255, 0.06);
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: 999px;
  padding: 3px;
  gap: 2px;
}

.tab,
.level-btn {
  appearance: none;
  border: none;
  background: transparent;
  color: var(--text-dim);
  border-radius: 999px;
  padding: 6px 13px;
  font-family: inherit;
  font-size: 0.82rem;
  font-weight: 500;
  line-height: 1;
  cursor: pointer;
  touch-action: manipulation;
  transition: color 0.15s, background 0.15s, box-shadow 0.15s;
}

.tab:hover,
.level-btn:hover {
  color: var(--text);
  background: rgba(255, 255, 255, 0.05);
}

.tab.active,
.level-btn.active {
  background: rgba(255, 255, 255, 0.12);
  color: var(--text);
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
}

/* â”€â”€ Settings Row â”€â”€ */
.settings-row {
  margin-top: 10px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  flex-wrap: wrap;
}

.ai-wrap {
  display: flex;
  align-items: center;
  gap: 8px;
}

.ai-wrap.hidden { display: none; }

.ai-label {
  font-size: 0.8rem;
  color: var(--text-dim);
  letter-spacing: 0.03em;
  text-transform: uppercase;
  font-weight: 500;
}

/* â”€â”€ Action Buttons â”€â”€ */
.actions {
  display: flex;
  gap: 6px;
}

.action-btn {
  appearance: none;
  border: 1px solid rgba(255, 255, 255, 0.1);
  background: rgba(255, 255, 255, 0.06);
  color: var(--text);
  border-radius: 999px;
  padding: 6px 14px;
  font-family: inherit;
  font-size: 0.82rem;
  font-weight: 500;
  line-height: 1;
  cursor: pointer;
  touch-action: manipulation;
  transition: background 0.15s, border-color 0.15s;
}

.action-btn:hover {
  background: rgba(255, 255, 255, 0.1);
  border-color: rgba(255, 255, 255, 0.18);
}

.action-btn:active {
  background: rgba(255, 255, 255, 0.14);
}

.action-btn:disabled {
  opacity: 0.35;
  cursor: not-allowed;
}

.action-btn.primary {
  background: rgba(74, 222, 128, 0.15);
  border-color: rgba(74, 222, 128, 0.25);
  color: var(--accent);
}

.action-btn.primary:hover {
  background: rgba(74, 222, 128, 0.22);
  border-color: rgba(74, 222, 128, 0.35);
}

/* â”€â”€ HUD Row â”€â”€ */
.hud-row {
  display: flex;
  flex-direction: column;
  gap: 8px;
  background: var(--panel-bg);
  border: 1px solid var(--panel-border);
  border-radius: 14px;
  padding: 10px 14px;
  box-shadow:
    0 1px 0 rgba(255,255,255,0.04) inset,
    0 8px 24px rgba(0, 0, 0, 0.35);
  flex-shrink: 0;
}

.hud-info {
  display: grid;
  grid-template-columns: 1fr auto 1fr;
  align-items: center;
  gap: 10px;
}

.turn-badge {
  display: flex;
  align-items: center;
  gap: 6px;
  font-weight: 700;
  font-size: 0.9rem;
}

.turn-stone {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  flex-shrink: 0;
}

.turn-stone.black {
  background:
    radial-gradient(circle at 36% 30%, rgba(255,255,255,0.10) 0%, transparent 28%),
    radial-gradient(ellipse at 40% 35%, #3a3a3a 0%, #181818 45%, #0e0e0e 80%, #080808 100%);
  box-shadow: 0 0 0 1px rgba(255,255,255,0.08);
}

.turn-stone.white {
  background: radial-gradient(circle at 35% 30%, #fff 0%, #d0d0d0 70%);
  box-shadow: 0 0 0 1px rgba(0,0,0,0.15);
}

/* â”€â”€ Score Display â”€â”€ */
.score-area {
  width: 100%;
}

.score-counts {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 5px;
  font-variant-numeric: tabular-nums;
  font-weight: 700;
  font-size: 0.88rem;
}

.score-disc {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  flex-shrink: 0;
}

.score-disc.black {
  background:
    radial-gradient(circle at 36% 30%, rgba(255,255,255,0.10) 0%, transparent 28%),
    radial-gradient(ellipse at 40% 35%, #3a3a3a 0%, #181818 45%, #0e0e0e 80%, #080808 100%);
  box-shadow: 0 0 0 1px rgba(255,255,255,0.08);
}

.score-disc.white {
  background: radial-gradient(circle at 35% 30%, #fff, #d0d0d0);
  box-shadow: 0 0 0 1px rgba(0,0,0,0.15);
}

.score-num {
  min-width: 22px;
  text-align: center;
}

.score-sep {
  color: var(--text-dim);
  margin: 0 2px;
  font-weight: 400;
}

.score-bar {
  height: 6px;
  border-radius: 3px;
  background: rgba(255, 255, 255, 0.08);
  overflow: hidden;
  display: flex;
}

.score-bar-black {
  background: #333;
  height: 100%;
  transition: width 0.4s ease;
  border-radius: 2px 0 0 2px;
}

.score-bar-white {
  background: #e0e0e0;
  height: 100%;
  transition: width 0.4s ease;
  border-radius: 0 2px 2px 0;
}

.state {
  font-size: 0.8rem;
  color: var(--text-dim);
  white-space: nowrap;
  text-align: right;
  justify-self: end;
}

/* â”€â”€ Precision Note â”€â”€ */
.precision-note {
  margin: 8px 0 0;
  padding: 6px 10px;
  border-radius: 8px;
  background: var(--accent-dim);
  font-size: 0.78rem;
  color: var(--accent);
  border: 1px solid rgba(74, 222, 128, 0.12);
}

.precision-note.hidden { display: none; }

/* â”€â”€ Board Shell â”€â”€ */
.board-shell {
  flex: 1;
  min-height: 500px;
  position: relative;
  background: rgba(255, 255, 255, 0.03);
  border-radius: 16px;
  border: 1px solid rgba(255, 255, 255, 0.06);
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 8px;
}

/* â”€â”€ Board â”€â”€ */
.board {
  --cell-size: 14px;
  position: relative;
  display: grid;
  aspect-ratio: 1 / 1;
  max-width: 100%;
  max-height: 100%;
  grid-template-columns: repeat(32, minmax(0, 1fr));
  grid-template-rows: repeat(32, minmax(0, 1fr));
  border-radius: 8px;
  overflow: hidden;
  border: 2px solid rgba(0, 0, 0, 0.4);
  background-color: var(--board);
  background-image:
    linear-gradient(135deg, rgba(255,255,255,0.04) 0%, transparent 50%, rgba(0,0,0,0.06) 100%);
  box-shadow:
    inset 0 1px 3px rgba(0, 0, 0, 0.25),
    inset 0 -1px 2px rgba(255, 255, 255, 0.05),
    0 4px 16px rgba(0, 0, 0, 0.3);
}

/* â”€â”€ Cells â”€â”€ */
.cell {
  appearance: none;
  -webkit-appearance: none;
  display: block;
  position: relative;
  border: none;
  margin: 0;
  padding: 0;
  background: transparent;
  box-shadow: inset -1px -1px 0 var(--line);
  cursor: pointer;
  touch-action: manipulation;
  overflow: hidden;
}

.cell:focus-visible {
  outline: 2px solid rgba(255, 255, 255, 0.85);
  outline-offset: -2px;
  z-index: 3;
}

.cell.armed {
  outline: 2px solid rgba(255, 215, 0, 0.95);
  outline-offset: -2px;
  z-index: 3;
}

.cell.legal {
  background: #1ba12a;
}

.cell.legal:hover {
  background: #1cad2d;
}

/* â”€â”€ Star Points â”€â”€ */
.star-point {
  position: absolute;
  width: 3px;
  height: 3px;
  border-radius: 50%;
  background: var(--star);
  pointer-events: none;
  z-index: 1;
  transform: translate(-50%, -50%);
}

/* â”€â”€ Stones â”€â”€ */
.stone,
.hint {
  position: absolute;
  width: 78%;
  height: 78%;
  border-radius: 50%;
  top: calc(50% - 0.5px);
  left: calc(50% - 0.5px);
  transform: translate(-50%, -50%);
}

.stone {
  z-index: 2;
}

.stone.black {
  background: radial-gradient(circle at 34% 28%, #292929 0, #0a0a0a 100%);
  box-shadow:
    0 1px 2px rgba(0, 0, 0, 0.5);
}

.stone.white {
  background: radial-gradient(circle at 34% 28%, var(--stone-white-a) 0, var(--stone-white-b) 100%);
  box-shadow:
    0 1px 2px rgba(0, 0, 0, 0.2);
}

.stone.pop {
  animation: piece-pop 0.15s ease-out;
}

/* â”€â”€ Last Move Marker â”€â”€ */
.last-move-marker {
  position: absolute;
  width: 3px;
  height: 3px;
  background: var(--last-move);
  top: calc(50% - 0.5px);
  left: calc(50% - 0.5px);
  transform: translate(-50%, -50%);
  z-index: 4;
  pointer-events: none;
}

/* â”€â”€ Hints â”€â”€ */
.hint {
  z-index: 1;
  opacity: 0.5;
  width: 1px;
  height: 1px;
}

.hint.black { background: #000; }
.hint.white { background: #fff; }

/* â”€â”€ Game Over Overlay â”€â”€ */
.game-over-overlay {
  position: fixed;
  inset: 0;
  --game-over-preview-size: clamp(132px, min(68vw, 38dvh), 260px);
  padding:
    max(12px, env(safe-area-inset-top))
    12px
    max(12px, env(safe-area-inset-bottom));
  border-radius: 0;
  background: rgba(11, 30, 16, 0.82);
  backdrop-filter: blur(3px);
  -webkit-backdrop-filter: blur(3px);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 12px;
  z-index: 30;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s ease;
}

.game-over-overlay.visible {
  opacity: 1;
  pointer-events: auto;
}

.game-over-title {
  font-size: clamp(1.3rem, 3vw, 2rem);
  font-weight: 400;
  color: var(--text);
  text-align: center;
}

.game-over-score {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: clamp(1rem, 2vw, 1.3rem);
  font-weight: 700;
  font-variant-numeric: tabular-nums;
}

.game-over-board {
  width: var(--game-over-preview-size);
  height: var(--game-over-preview-size);
  border-radius: 3px;
  border: 1px solid rgba(255, 255, 255, 0.22);
  background: rgba(0, 0, 0, 0.16);
  box-shadow: 0 8px 22px rgba(0, 0, 0, 0.35);
  overflow: hidden;
  flex-shrink: 0;
}

.game-over-board.hidden {
  display: none;
}

.game-over-board img {
  display: block;
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.game-over-actions {
  width: var(--game-over-preview-size);
  display: grid;
  gap: 8px;
  flex-shrink: 0;
}

.game-over-disc {
  width: 18px;
  height: 18px;
  border-radius: 50%;
}

.game-over-disc.black {
  background: radial-gradient(circle at 35% 30%, #555, #111);
  box-shadow: 0 0 0 1px rgba(255,255,255,0.15);
}

.game-over-disc.white {
  background: radial-gradient(circle at 35% 30%, #fff, #ccc);
  box-shadow: 0 0 0 1px rgba(0,0,0,0.15);
}

.game-over-sep {
  color: var(--text-dim);
  font-weight: 400;
}

.game-over-btn {
  appearance: none;
  border: 1px solid rgba(74, 222, 128, 0.3);
  background: rgba(74, 222, 128, 0.15);
  color: var(--accent);
  border-radius: 999px;
  padding: 9px 22px;
  font-family: inherit;
  font-size: 0.88rem;
  font-weight: 600;
  cursor: pointer;
  transition: background 0.15s;
  margin-top: 2px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.game-over-btn:hover {
  background: rgba(74, 222, 128, 0.25);
}

.game-over-btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
}

.game-over-btn:disabled:hover {
  background: rgba(74, 222, 128, 0.15);
}

.game-over-btn.share {
  border-color: rgba(255, 255, 255, 0.25);
  background:
    radial-gradient(circle at 12% 18%, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0) 40%),
    linear-gradient(140deg, rgba(32, 32, 32, 0.98), rgba(6, 6, 6, 0.98));
  color: #f7fafc;
  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.35);
}

.game-over-btn.share:hover {
  background:
    radial-gradient(circle at 12% 18%, rgba(255, 255, 255, 0.24), rgba(255, 255, 255, 0) 40%),
    linear-gradient(140deg, rgba(42, 42, 42, 0.98), rgba(10, 10, 10, 0.98));
}

.game-over-btn.share:disabled:hover {
  background:
    radial-gradient(circle at 12% 18%, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0) 40%),
    linear-gradient(140deg, rgba(32, 32, 32, 0.98), rgba(6, 6, 6, 0.98));
}

.game-over-btn.save {
  border-color: rgba(255, 255, 255, 0.22);
  background: rgba(255, 255, 255, 0.1);
  color: var(--text);
}

.game-over-btn.save:hover {
  background: rgba(255, 255, 255, 0.16);
}

.game-over-btn.save:disabled:hover {
  background: rgba(255, 255, 255, 0.1);
}

/* â”€â”€ Toast â”€â”€ */
.toast {
  position: fixed;
  left: 50%;
  bottom: 18px;
  transform: translate(-50%, 14px);
  padding: 9px 13px;
  border-radius: 999px;
  color: #f5fff4;
  background: rgba(15, 28, 16, 0.9);
  border: 1px solid rgba(255, 255, 255, 0.18);
  box-shadow: 0 6px 20px rgba(0, 0, 0, 0.36);
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.2s ease, transform 0.2s ease;
  font-size: 0.85rem;
  z-index: 20;
}

.toast.show {
  opacity: 1;
  transform: translate(-50%, 0);
}

@keyframes piece-pop {
  from { transform: translate(-50%, -50%) scale(0); }
  to { transform: translate(-50%, -50%) scale(1); }
}

/* â”€â”€ Responsive â”€â”€ */
@media (max-width: 599px) {
  .app {
    padding: 6px 6px 8px;
    gap: 6px;
  }

  .top-panel {
    padding: 10px;
  }

  .tab,
  .level-btn {
    padding: 5px 10px;
    font-size: 0.78rem;
  }

  .action-btn {
    padding: 5px 10px;
    font-size: 0.78rem;
  }

  .state {
    font-size: 0.76rem;
  }

  .board-shell {
    padding: 4px;
    min-height: 0;
  }

  .hud-row {
    gap: 6px;
    padding: 8px 10px;
  }

  .hud-info {
    gap: 6px;
  }

  .game-over-overlay {
    --game-over-preview-size: clamp(112px, min(62vw, 30dvh), 200px);
    gap: 10px;
    padding:
      max(10px, env(safe-area-inset-top))
      10px
      max(10px, env(safe-area-inset-bottom));
  }

  .star-point {
    width: 4px;
    height: 4px;
  }
}

/* â”€â”€ Footer â”€â”€ */
.site-footer {
  text-align: center;
  padding: 10px 14px 14px;
  font-size: 0.78rem;
  color: var(--text-dim);
  line-height: 1.6;
  flex-shrink: 0;
}

.site-footer a {
  color: var(--accent);
  text-decoration: none;
  font-weight: 500;
  transition: color 0.15s;
}

.site-footer a:hover {
  text-decoration: underline;
  color: #6ee7a0;
}

.footer-divider {
  display: inline-block;
  width: 28px;
  height: 1px;
  background: rgba(255, 255, 255, 0.1);
  vertical-align: middle;
  margin: 0 6px;
}

/* â”€â”€ Description â”€â”€ */
.description {
  max-width: 720px;
  margin: 8px auto 0;
  padding: 18px 20px;
  background: var(--panel-bg);
  border: 1px solid var(--panel-border);
  border-radius: 14px;
  box-shadow:
    0 1px 0 rgba(255,255,255,0.04) inset,
    0 8px 24px rgba(0, 0, 0, 0.35);
  font-size: 0.88rem;
  line-height: 1.8;
  color: var(--text-dim);
}

.description h2 {
  font-size: 1rem;
  font-weight: 600;
  color: var(--text);
  margin-bottom: 8px;
}

.description p {
  margin: 0;
}

@media (max-width: 599px) {
  .description {
    padding: 14px 14px;
    font-size: 0.82rem;
  }
}


</style>
</head>
<body>
<div class="app">
  <section class="top-panel">
    <div class="title-row">
      <h1 class="title">å·¨å¤§ãƒªãƒãƒ¼ã‚·</h1>
      <div class="mode-tabs" role="tablist" aria-label="å¯¾æˆ¦ãƒ¢ãƒ¼ãƒ‰">
        <button type="button" class="tab" data-mode="pvp">ã‚ªã‚»ãƒ­ç›¤</button>
        <button type="button" class="tab active" data-mode="ai">AIå¯¾æˆ¦</button>
      </div>
    </div>
    <div class="settings-row">
      <div class="ai-wrap" id="aiWrap">
        <span class="ai-label">AIé›£æ˜“åº¦</span>
        <div class="level-tabs" role="group" aria-label="AIé›£æ˜“åº¦">
          <button type="button" class="level-btn" data-level="1">åˆç´š</button>
          <button type="button" class="level-btn active" data-level="2">ä¸­ç´š</button>
          <button type="button" class="level-btn" data-level="3">ä¸Šç´š</button>
        </div>
      </div>
      <div class="actions">
        <button type="button" class="action-btn primary" id="newGameBtn">æ–°è¦ã‚²ãƒ¼ãƒ </button>
        <button type="button" class="action-btn" id="undoBtn">ä¸€æ‰‹æˆ»ã™</button>
      </div>
    </div>
    <p class="precision-note hidden" id="precisionNote">ã‚»ãƒ«ãŒå°ã•ã„ãŸã‚ã€èª¤ã‚¿ãƒƒãƒé˜²æ­¢ã§ã€Œ2å›ã‚¿ãƒƒãƒ—ã€ã§ç€æ‰‹ã—ã¾ã™ã€‚</p>
  </section>
  <section class="board-shell" id="boardShell">
    <div class="board" id="board" role="grid" aria-label="32x32 ã‚ªã‚»ãƒ­ç›¤"></div>
    <div class="game-over-overlay" id="gameOverOverlay">
      <div class="game-over-title" id="gameOverTitle">ã‚²ãƒ¼ãƒ çµ‚äº†</div>
      <div class="game-over-score" id="gameOverScore">
        <span class="game-over-disc black"></span>
        <span id="goBlack">2</span>
        <span class="game-over-sep">â€”</span>
        <span id="goWhite">2</span>
        <span class="game-over-disc white"></span>
      </div>
      <div class="game-over-board hidden" id="gameOverBoardWrap">
        <img id="gameOverBoardImage" alt="æœ€çµ‚ç›¤é¢ã®ç”»åƒ" loading="lazy" />
      </div>
      <div class="game-over-actions">
        <button type="button" class="game-over-btn save" id="saveBoardBtn" disabled>ç›¤é¢ç”»åƒã‚’ä¿å­˜</button>
        <button type="button" class="game-over-btn share" id="shareResultBtn" disabled>
          <span>ğ• ã§çµæœã‚’æŠ•ç¨¿</span>
        </button>
      </div>
      <button type="button" class="game-over-btn" id="gameOverBtn">æ–°è¦ã‚²ãƒ¼ãƒ </button>
    </div>
  </section>
  <section class="hud-row">
    <div class="hud-info">
      <div class="turn-badge" id="turnBadge">
        <span class="turn-stone black"></span>
        <span>æ‰‹ç•ª: é»’</span>
      </div>
      <div class="score-counts" id="scoreLine">
        <span class="score-disc black"></span>
        <span class="score-num" id="blackCount">2</span>
        <span class="score-sep">â€”</span>
        <span class="score-num" id="whiteCount">2</span>
        <span class="score-disc white"></span>
      </div>
      <div class="state" id="stateLine">åˆæ³•æ‰‹ 4</div>
    </div>
    <div class="score-area" id="scoreArea">
      <div class="score-bar">
        <div class="score-bar-black" id="scoreBarBlack" style="width:50%"></div>
        <div class="score-bar-white" id="scoreBarWhite" style="width:50%"></div>
      </div>
    </div>
  </section>
  <section class="description">
  <h2>å·¨å¤§ãƒªãƒãƒ¼ã‚·ï¼ˆã‚ªã‚»ãƒ­ï¼‰</h2>
  <p>32Ã—32ãƒã‚¹ã®ç›¤é¢ã§éŠã¶ã‚ªã‚»ãƒ­ã‚²ãƒ¼ãƒ ã§ã™ã€‚ç›¤é¢ãŒåºƒã™ãã¦è§’ã‚„è¾ºã«ã¯ãªã‹ãªã‹ãŸã©ã‚Šç€ã‘ãªã„ãŸã‚ã€8Ã—8ã®ã‚ªã‚»ãƒ­ã¨ã¯ç•°ãªã‚‹æˆ¦ç•¥ã‚’è€ƒãˆã‚‹ã“ã¨ãŒé‡è¦ã«ãªã‚Šã¾ã™ã€‚çµ‚ç›¤ã€å¤§é‡ã®çŸ³ãŒä¸€æ°—ã«ã²ã£ãã‚Šè¿”ã‚‹ç¬é–“ã¯ã¨ã«ã‹ãçˆ½å¿«ï¼æ™®æ®µã‚ªã‚»ãƒ­ã‚’ã‚„ã‚Šæ…£ã‚Œã¦ã„ã‚‹æ–¹ã«ã‚‚ãœã²ä¸€åº¦è©¦ã—ã¦ã»ã—ã„æ–°æ„Ÿè¦šã®ã‚²ãƒ¼ãƒ ã§ã™ã€‚</p>
</section>
</div>
<footer class="site-footer">
  åˆ¶ä½œï¼š<a href="https://yuki-lab.com/" rel="noopener">Yuki Lab</a> | äººæ°—ã‚ªã‚»ãƒ­ã‚µã‚¤ãƒˆ <a href="https://reversi.yuki-lab.com" target="_blank" rel="noopener">ãƒªãƒãƒ¼ã‚·Web</a> ã®ä¸€å‘¨å¹´è¨˜å¿µã‚¹ãƒ”ãƒ³ã‚ªãƒ•ä½œå“ã§ã™<br>
</footer>
<div class="toast" id="toast" role="status" aria-live="polite"></div>

<script>
(() => {
  "use strict";

  const BOARD_SIZE = 32;
  const EMPTY = 0;
  const BLACK = 1;
  const WHITE = 2;
  const DIRECTIONS = [
    [-1, -1], [-1, 0], [-1, 1],
    [0, -1],           [0, 1],
    [1, -1],  [1, 0],  [1, 1]
  ];
  const AI_LEVEL_LABELS = {
    1: "åˆç´š",
    2: "ä¸­ç´š",
    3: "ä¸Šç´š"
  };

  // Star point positions for 32x32 (like Go board reference points)
  const STAR_POINTS = [
    [8, 8], [8, 16], [8, 24],
    [16, 8], [16, 16], [16, 24],
    [24, 8], [24, 16], [24, 24]
  ];

  const boardEl = document.getElementById("board");
  const boardShellEl = document.getElementById("boardShell");
  const turnBadgeEl = document.getElementById("turnBadge");
  const stateLineEl = document.getElementById("stateLine");
  const toastEl = document.getElementById("toast");
  const undoBtn = document.getElementById("undoBtn");
  const newGameBtn = document.getElementById("newGameBtn");
  const precisionNoteEl = document.getElementById("precisionNote");
  const aiWrapEl = document.getElementById("aiWrap");
  const modeTabs = Array.from(document.querySelectorAll(".tab"));
  const levelTabs = Array.from(document.querySelectorAll(".level-btn"));

  // Score elements
  const blackCountEl = document.getElementById("blackCount");
  const whiteCountEl = document.getElementById("whiteCount");
  const scoreBarBlackEl = document.getElementById("scoreBarBlack");
  const scoreBarWhiteEl = document.getElementById("scoreBarWhite");

  // Game over elements
  const gameOverOverlay = document.getElementById("gameOverOverlay");
  const gameOverTitle = document.getElementById("gameOverTitle");
  const goBlackEl = document.getElementById("goBlack");
  const goWhiteEl = document.getElementById("goWhite");
  const gameOverBoardWrap = document.getElementById("gameOverBoardWrap");
  const gameOverBoardImage = document.getElementById("gameOverBoardImage");
  const shareResultBtn = document.getElementById("shareResultBtn");
  const saveBoardBtn = document.getElementById("saveBoardBtn");
  const gameOverBtn = document.getElementById("gameOverBtn");

  const cellEls = new Array(BOARD_SIZE * BOARD_SIZE);
  const stoneEls = new Array(BOARD_SIZE * BOARD_SIZE).fill(null);
  const hintEls = new Array(BOARD_SIZE * BOARD_SIZE).fill(null);
  const board = Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(EMPTY));

  let mode = "ai";
  let aiLevel = 2;
  let currentPlayer = BLACK;
  let gameOver = false;
  let aiThinking = false;
  let aiTimer = null;
  let toastTimer = null;
  let legalCachePlayer = null;
  let legalMovesCache = new Map();
  let highlighted = new Set();
  let armedCell = null;
  let precisionTapMode = false;
  let resizeRaf = null;
  let lastMoveIdx = null;
  let lastMoveMarkerEl = null;

  const history = [];

  const toIndex = (row, col) => row * BOARD_SIZE + col;
  const rowOf = (idx) => Math.floor(idx / BOARD_SIZE);
  const colOf = (idx) => idx % BOARD_SIZE;
  const inBounds = (row, col) => row >= 0 && row < BOARD_SIZE && col >= 0 && col < BOARD_SIZE;
  const opposite = (player) => (player === BLACK ? WHITE : BLACK);
  const colorName = (player) => (player === BLACK ? "é»’" : "ç™½");
  const pad2 = (value) => String(value).padStart(2, "0");

  function getResultLabel(counts) {
    if (counts.black === counts.white) {
      return "å¼•ãåˆ†ã‘";
    }
    return counts.black > counts.white ? "é»’ã®å‹ã¡" : "ç™½ã®å‹ã¡";
  }

  function buildShareText(counts) {
    const modeLabel = mode === "ai"
      ? `AIå¯¾æˆ¦ (${AI_LEVEL_LABELS[aiLevel] || "ä¸­ç´š"})`
      : "ã‚ªã‚»ãƒ­ç›¤";
    const resultLabel = getResultLabel(counts);
    return `å·¨å¤§ãƒªãƒãƒ¼ã‚·ï¼ˆ${modeLabel}ãƒ¢ãƒ¼ãƒ‰ï¼‰\n\nçµæœ: ${resultLabel}ï¼ˆé»’${counts.black} - ç™½${counts.white}ï¼‰\n\n#YukiLabã®å·¨å¤§ãƒªãƒãƒ¼ã‚· #ã‚ªã‚»ãƒ­`;
  }

  function buildSnapshotFilename(counts) {
    const outcome = counts.black === counts.white
      ? "draw"
      : counts.black > counts.white
        ? "black-win"
        : "white-win";
    const now = new Date();
    const stamp = `${now.getFullYear()}${pad2(now.getMonth() + 1)}${pad2(now.getDate())}-${pad2(now.getHours())}${pad2(now.getMinutes())}${pad2(now.getSeconds())}`;
    return `big-reversi-${outcome}-b${counts.black}-w${counts.white}-${stamp}.png`;
  }

  function shareResultOnX() {
    if (!gameOver) {
      return;
    }
    const counts = countPieces();
    const params = new URLSearchParams({
      text: buildShareText(counts),
      url: document.querySelector("link[rel='canonical']")?.href || window.location.href
    });
    const shareUrl = `https://x.com/intent/tweet?${params.toString()}`;
    window.open(shareUrl, "_blank");
    showToast("XæŠ•ç¨¿ç”»é¢ã‚’é–‹ãã¾ã—ãŸ");
  }

  function downloadBoardSnapshot() {
    const snapshot = gameOverBoardImage.getAttribute("src");
    if (!snapshot) {
      showToast("ä¿å­˜ã§ãã‚‹ç›¤é¢ç”»åƒãŒã‚ã‚Šã¾ã›ã‚“");
      return;
    }
    const counts = countPieces();
    const downloadLink = document.createElement("a");
    downloadLink.href = snapshot;
    downloadLink.download = buildSnapshotFilename(counts);
    document.body.appendChild(downloadLink);
    downloadLink.click();
    downloadLink.remove();
    showToast("ç›¤é¢ç”»åƒã‚’ä¿å­˜ã—ã¾ã—ãŸ");
  }

  function showToast(message, duration = 1600) {
    toastEl.textContent = message;
    toastEl.classList.add("show");
    if (toastTimer) {
      clearTimeout(toastTimer);
    }
    toastTimer = setTimeout(() => {
      toastEl.classList.remove("show");
      toastTimer = null;
    }, duration);
  }

  function cancelAiTurn() {
    if (aiTimer) {
      clearTimeout(aiTimer);
      aiTimer = null;
    }
    aiThinking = false;
  }

  function invalidateLegalCache() {
    legalCachePlayer = null;
    legalMovesCache = new Map();
  }

  function buildBoardDOM() {
    const fragment = document.createDocumentFragment();
    for (let idx = 0; idx < BOARD_SIZE * BOARD_SIZE; idx += 1) {
      const cell = document.createElement("button");
      cell.type = "button";
      cell.className = "cell";
      cell.dataset.idx = String(idx);
      cell.setAttribute("role", "gridcell");
      fragment.appendChild(cell);
      cellEls[idx] = cell;
    }
    boardEl.appendChild(fragment);
  }

  function placeStarPoints() {
    for (const [row, col] of STAR_POINTS) {
      const dot = document.createElement("div");
      dot.className = "star-point";
      dot.style.left = `${(col / BOARD_SIZE) * 99.8}%`;
      dot.style.top = `${(row / BOARD_SIZE) * 99.8}%`;
      boardEl.appendChild(dot);
    }
  }

  function clearArmedCell() {
    if (armedCell !== null) {
      cellEls[armedCell].classList.remove("armed");
      armedCell = null;
    }
  }

  function armCell(idx) {
    if (armedCell === idx) {
      return;
    }
    clearArmedCell();
    armedCell = idx;
    cellEls[idx].classList.add("armed");
  }

  function clearLastMoveMarker() {
    if (lastMoveMarkerEl) {
      lastMoveMarkerEl.remove();
      lastMoveMarkerEl = null;
    }
    lastMoveIdx = null;
  }

  function setLastMoveMarker(idx) {
    clearLastMoveMarker();
    lastMoveIdx = idx;
    const marker = document.createElement("div");
    marker.className = "last-move-marker";
    cellEls[idx].appendChild(marker);
    lastMoveMarkerEl = marker;
  }

  function setStone(idx, value, animate = false) {
    const row = rowOf(idx);
    const col = colOf(idx);
    board[row][col] = value;

    const cell = cellEls[idx];
    let stone = stoneEls[idx];

    if (value === EMPTY) {
      if (stone) {
        stone.remove();
        stoneEls[idx] = null;
      }
      return;
    }

    if (!stone) {
      stone = document.createElement("div");
      stone.className = "stone";
      cell.appendChild(stone);
      stoneEls[idx] = stone;
    }

    stone.classList.toggle("black", value === BLACK);
    stone.classList.toggle("white", value === WHITE);

    if (animate) {
      stone.classList.remove("pop");
      void stone.offsetWidth;
      stone.classList.add("pop");
    }
  }

  function updateHighlights(moves) {
    const next = new Set(moves.keys());

    for (const idx of highlighted) {
      if (next.has(idx)) {
        continue;
      }
      if (hintEls[idx]) {
        hintEls[idx].remove();
        hintEls[idx] = null;
      }
      cellEls[idx].classList.remove("legal");
    }

    for (const idx of next) {
      if (!hintEls[idx]) {
        const hint = document.createElement("div");
        hint.className = "hint";
        cellEls[idx].appendChild(hint);
        hintEls[idx] = hint;
      }
      hintEls[idx].classList.toggle("black", currentPlayer === BLACK);
      hintEls[idx].classList.toggle("white", currentPlayer === WHITE);
      cellEls[idx].classList.add("legal");
    }

    highlighted = next;
  }

  function hasAnyFlip(index, player, boardRef = board) {
    const row = rowOf(index);
    const col = colOf(index);

    if (boardRef[row][col] !== EMPTY) {
      return false;
    }

    const enemy = opposite(player);

    for (const [dr, dc] of DIRECTIONS) {
      let r = row + dr;
      let c = col + dc;
      let seenEnemy = false;

      while (inBounds(r, c) && boardRef[r][c] === enemy) {
        seenEnemy = true;
        r += dr;
        c += dc;
      }

      if (seenEnemy && inBounds(r, c) && boardRef[r][c] === player) {
        return true;
      }
    }

    return false;
  }

  function collectFlips(index, player, boardRef = board) {
    const row = rowOf(index);
    const col = colOf(index);

    if (boardRef[row][col] !== EMPTY) {
      return [];
    }

    const enemy = opposite(player);
    const flips = [];

    for (const [dr, dc] of DIRECTIONS) {
      let r = row + dr;
      let c = col + dc;
      const line = [];

      while (inBounds(r, c) && boardRef[r][c] === enemy) {
        line.push(toIndex(r, c));
        r += dr;
        c += dc;
      }

      if (line.length > 0 && inBounds(r, c) && boardRef[r][c] === player) {
        flips.push(...line);
      }
    }

    return flips;
  }

  function computeLegalMoves(player, boardRef = board) {
    const moves = new Map();
    for (let row = 0; row < BOARD_SIZE; row += 1) {
      for (let col = 0; col < BOARD_SIZE; col += 1) {
        if (boardRef[row][col] !== EMPTY) {
          continue;
        }
        const idx = toIndex(row, col);
        const flips = collectFlips(idx, player, boardRef);
        if (flips.length > 0) {
          moves.set(idx, flips);
        }
      }
    }
    return moves;
  }

  function computeLegalMoveCount(player, boardRef = board) {
    let count = 0;
    for (let row = 0; row < BOARD_SIZE; row += 1) {
      for (let col = 0; col < BOARD_SIZE; col += 1) {
        if (boardRef[row][col] !== EMPTY) {
          continue;
        }
        if (hasAnyFlip(toIndex(row, col), player, boardRef)) {
          count += 1;
        }
      }
    }
    return count;
  }

  function ensureLegalMoves() {
    if (legalCachePlayer === currentPlayer) {
      return legalMovesCache;
    }
    legalMovesCache = computeLegalMoves(currentPlayer);
    legalCachePlayer = currentPlayer;
    return legalMovesCache;
  }

  function countPieces() {
    let black = 0;
    let white = 0;
    let empty = 0;

    for (let row = 0; row < BOARD_SIZE; row += 1) {
      for (let col = 0; col < BOARD_SIZE; col += 1) {
        const value = board[row][col];
        if (value === BLACK) {
          black += 1;
        } else if (value === WHITE) {
          white += 1;
        } else {
          empty += 1;
        }
      }
    }

    return { black, white, empty };
  }

  function updateScoreBar(counts) {
    const total = counts.black + counts.white;
    if (total === 0) {
      scoreBarBlackEl.style.width = "50%";
      scoreBarWhiteEl.style.width = "50%";
    } else {
      const blackPct = (counts.black / total) * 100;
      const whitePct = (counts.white / total) * 100;
      scoreBarBlackEl.style.width = `${blackPct}%`;
      scoreBarWhiteEl.style.width = `${whitePct}%`;
    }
  }

  function createBoardSnapshotDataUrl() {
    const size = 768;
    const border = 8;
    const inner = size - border * 2;
    const cell = inner / BOARD_SIZE;
    const markerRadius = Math.max(2, cell * 0.12);

    const canvas = document.createElement("canvas");
    canvas.width = size;
    canvas.height = size;

    const ctx = canvas.getContext("2d");
    if (!ctx) {
      return "";
    }

    const gradient = ctx.createLinearGradient(0, border, 0, size - border);
    gradient.addColorStop(0, "#13952b");
    gradient.addColorStop(1, "#0d741f");

    ctx.fillStyle = "rgba(0, 0, 0, 0.45)";
    ctx.fillRect(0, 0, size, size);
    ctx.fillStyle = gradient;
    ctx.fillRect(border, border, inner, inner);

    ctx.strokeStyle = "rgba(10, 100, 20, 0.95)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    for (let i = 0; i <= BOARD_SIZE; i += 1) {
      const p = border + i * cell;
      ctx.moveTo(border, p);
      ctx.lineTo(size - border, p);
      ctx.moveTo(p, border);
      ctx.lineTo(p, size - border);
    }
    ctx.stroke();

    ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
    for (const [row, col] of STAR_POINTS) {
      const x = border + (col + 0.5) * cell;
      const y = border + (row + 0.5) * cell;
      ctx.beginPath();
      ctx.arc(x, y, Math.max(1.8, cell * 0.16), 0, Math.PI * 2);
      ctx.fill();
    }

    const stoneRadius = cell * 0.39;
    for (let row = 0; row < BOARD_SIZE; row += 1) {
      for (let col = 0; col < BOARD_SIZE; col += 1) {
        const value = board[row][col];
        if (value === EMPTY) {
          continue;
        }

        const x = border + (col + 0.5) * cell;
        const y = border + (row + 0.5) * cell;
        const gradient = ctx.createRadialGradient(
          x - stoneRadius * 0.32,
          y - stoneRadius * 0.36,
          stoneRadius * 0.12,
          x,
          y,
          stoneRadius
        );

        if (value === BLACK) {
          gradient.addColorStop(0, "#313131");
          gradient.addColorStop(1, "#0a0a0a");
        } else {
          gradient.addColorStop(0, "#ffffff");
          gradient.addColorStop(1, "#bdbdbd");
        }

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, stoneRadius, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    if (lastMoveIdx !== null) {
      const row = rowOf(lastMoveIdx);
      const col = colOf(lastMoveIdx);
      const x = border + (col + 0.5) * cell;
      const y = border + (row + 0.5) * cell;
      ctx.fillStyle = "#ef4444";
      ctx.beginPath();
      ctx.arc(x, y, markerRadius, 0, Math.PI * 2);
      ctx.fill();
    }

    return canvas.toDataURL("image/png");
  }

  function updateGameOverBoardImage() {
    const snapshot = createBoardSnapshotDataUrl();
    if (!snapshot) {
      gameOverBoardImage.removeAttribute("src");
      gameOverBoardWrap.classList.add("hidden");
      saveBoardBtn.disabled = true;
      return;
    }

    gameOverBoardImage.src = snapshot;
    gameOverBoardWrap.classList.remove("hidden");
    saveBoardBtn.disabled = false;
  }

  function showGameOverOverlay(counts) {
    goBlackEl.textContent = counts.black;
    goWhiteEl.textContent = counts.white;
    gameOverTitle.textContent = getResultLabel(counts);

    updateGameOverBoardImage();
    shareResultBtn.disabled = false;
    gameOverOverlay.classList.add("visible");
  }

  function hideGameOverOverlay() {
    gameOverOverlay.classList.remove("visible");
    gameOverBoardImage.removeAttribute("src");
    gameOverBoardWrap.classList.add("hidden");
    shareResultBtn.disabled = true;
    saveBoardBtn.disabled = true;
  }

  function updateStatus(legalCount = null) {
    const counts = countPieces();
    blackCountEl.textContent = counts.black;
    whiteCountEl.textContent = counts.white;
    updateScoreBar(counts);

    if (gameOver) {
      const turnStone = turnBadgeEl.querySelector(".turn-stone");
      turnStone.className = "turn-stone";
      turnBadgeEl.querySelector("span:last-child").textContent = "ã‚²ãƒ¼ãƒ çµ‚äº†";
      stateLineEl.textContent = getResultLabel(counts);
      undoBtn.disabled = history.length === 0;
      showGameOverOverlay(counts);
      return;
    }

    hideGameOverOverlay();

    const turnStone = turnBadgeEl.querySelector(".turn-stone");
    turnStone.classList.toggle("black", currentPlayer === BLACK);
    turnStone.classList.toggle("white", currentPlayer === WHITE);
    turnBadgeEl.querySelector("span:last-child").textContent = `æ‰‹ç•ª: ${colorName(currentPlayer)}`;

    const moves = legalCount === null ? ensureLegalMoves().size : legalCount;
    if (aiThinking && mode === "ai" && currentPlayer === WHITE) {
      stateLineEl.textContent = `AIãŒè€ƒãˆä¸­â€¦ï¼ˆåˆæ³•æ‰‹ ${moves}ï¼‰`;
    } else {
      stateLineEl.textContent = `åˆæ³•æ‰‹ ${moves}`;
    }

    undoBtn.disabled = history.length === 0;
  }

  function positionWeight(index) {
    const row = rowOf(index);
    const col = colOf(index);
    const last = BOARD_SIZE - 1;

    const top = row === 0;
    const bottom = row === last;
    const left = col === 0;
    const right = col === last;

    if ((top || bottom) && (left || right)) {
      return 170;
    }

    let score = 0;
    if (top || bottom || left || right) {
      score += 24;
    }

    const nearTop = row === 1;
    const nearBottom = row === last - 1;
    const nearLeft = col === 1;
    const nearRight = col === last - 1;

    if ((nearTop || nearBottom) && (left || right)) {
      score -= 36;
    }
    if ((nearLeft || nearRight) && (top || bottom)) {
      score -= 36;
    }
    if ((nearTop || nearBottom) && (nearLeft || nearRight)) {
      score -= 48;
    }

    const dist = Math.min(row, col, last - row, last - col);
    score += Math.min(dist, 6) * 2;

    return score;
  }

  function chooseAiMove(moves) {
    const entries = Array.from(moves.entries());
    if (entries.length === 0) {
      return null;
    }

    if (aiLevel === 1) {
      return entries[Math.floor(Math.random() * entries.length)][0];
    }

    const counts = countPieces();
    const lateGame = counts.empty < 180;

    if (aiLevel === 2) {
      const scored = entries.map(([idx, flips]) => ({
        idx,
        score: flips.length * (lateGame ? 4 : 2) + positionWeight(idx) * 0.5
      }));
      scored.sort((a, b) => b.score - a.score);
      // Pick randomly from top 40% of candidates (at least 2)
      const poolSize = Math.max(2, Math.ceil(scored.length * 0.4));
      const pool = scored.slice(0, poolSize);
      return pool[Math.floor(Math.random() * pool.length)].idx;
    }

    const quickScores = entries.map(([idx, flips]) => {
      const score = flips.length * (lateGame ? 6 : 3) + positionWeight(idx);
      return { idx, flips, score };
    });

    quickScores.sort((a, b) => b.score - a.score);
    const candidateCount = Math.min(8, quickScores.length);
    let best = quickScores[0];
    let bestFinalScore = -Infinity;

    for (let i = 0; i < candidateCount; i += 1) {
      const candidate = quickScores[i];
      const changed = [candidate.idx, ...candidate.flips];
      const previous = new Array(changed.length);

      for (let j = 0; j < changed.length; j += 1) {
        const index = changed[j];
        const row = rowOf(index);
        const col = colOf(index);
        previous[j] = board[row][col];
        board[row][col] = WHITE;
      }

      const opponentMoves = computeLegalMoveCount(BLACK);
      let finalScore = candidate.score - opponentMoves * 2.8;
      if (opponentMoves === 0) {
        finalScore += 120;
      }

      for (let j = 0; j < changed.length; j += 1) {
        const index = changed[j];
        const row = rowOf(index);
        const col = colOf(index);
        board[row][col] = previous[j];
      }

      if (finalScore > bestFinalScore) {
        bestFinalScore = finalScore;
        best = candidate;
      }
    }

    return best.idx;
  }

  function applyMove(index) {
    if (gameOver) {
      return;
    }

    const legalMoves = ensureLegalMoves();
    const flips = legalMoves.get(index);
    if (!flips) {
      return;
    }

    history.push({
      mover: currentPlayer,
      placed: index,
      flips: flips.slice()
    });

    setStone(index, currentPlayer, true);
    for (const flipIndex of flips) {
      setStone(flipIndex, currentPlayer, false);
    }

    setLastMoveMarker(index);

    currentPlayer = opposite(currentPlayer);
    invalidateLegalCache();
    settleTurn();
  }

  function revertRecord(record) {
    setStone(record.placed, EMPTY, false);
    const rollbackColor = opposite(record.mover);
    for (const idx of record.flips) {
      setStone(idx, rollbackColor, false);
    }
    currentPlayer = record.mover;
    gameOver = false;
    invalidateLegalCache();
  }

  function undoMove() {
    if (history.length === 0) {
      return;
    }

    cancelAiTurn();
    clearArmedCell();

    let undoSteps = 1;
    if (mode === "ai" && currentPlayer === BLACK && history.length >= 2) {
      const latest = history[history.length - 1];
      if (latest.mover === WHITE) {
        undoSteps = 2;
      }
    }

    for (let i = 0; i < undoSteps; i += 1) {
      const record = history.pop();
      if (!record) {
        break;
      }
      revertRecord(record);
    }

    // Update last move marker to previous move
    clearLastMoveMarker();
    if (history.length > 0) {
      setLastMoveMarker(history[history.length - 1].placed);
    }

    settleTurn({ silentPassToast: true });
  }

  function settleTurn(options = {}) {
    const silentPassToast = Boolean(options.silentPassToast);
    clearArmedCell();
    cancelAiTurn();

    if (gameOver) {
      updateHighlights(new Map());
      updateStatus(0);
      return;
    }

    let passCount = 0;

    while (passCount < 2) {
      const moves = ensureLegalMoves();
      updateHighlights(moves);
      updateStatus(moves.size);

      if (moves.size > 0) {
        if (mode === "ai" && currentPlayer === WHITE) {
          aiThinking = true;
          updateStatus(moves.size);
          aiTimer = setTimeout(() => {
            aiTimer = null;
            aiThinking = false;

            if (mode !== "ai" || gameOver || currentPlayer !== WHITE) {
              updateStatus();
              return;
            }

            const cachedMoves = ensureLegalMoves();
            if (cachedMoves.size === 0) {
              settleTurn({ silentPassToast: true });
              return;
            }

            const aiChoice = chooseAiMove(cachedMoves);
            if (aiChoice !== null) {
              applyMove(aiChoice);
            }
          }, 300);
        }
        return;
      }

      const passed = currentPlayer;
      currentPlayer = opposite(currentPlayer);
      invalidateLegalCache();
      passCount += 1;

      if (passCount === 1 && !silentPassToast) {
        showToast(`${colorName(passed)}ã¯ç½®ã‘ã‚‹å ´æ‰€ãŒãªã„ãŸã‚ãƒ‘ã‚¹`);
      }
    }

    gameOver = true;
    updateHighlights(new Map());
    updateStatus(0);

    const { black, white } = countPieces();
    if (!silentPassToast) {
      if (black === white) {
        showToast(`ã‚²ãƒ¼ãƒ çµ‚äº†: å¼•ãåˆ†ã‘ï¼ˆé»’${black} - ç™½${white}ï¼‰`, 2600);
      } else if (black > white) {
        showToast(`ã‚²ãƒ¼ãƒ çµ‚äº†: é»’ã®å‹ã¡ï¼ˆé»’${black} - ç™½${white}ï¼‰`, 2600);
      } else {
        showToast(`ã‚²ãƒ¼ãƒ çµ‚äº†: ç™½ã®å‹ã¡ï¼ˆé»’${black} - ç™½${white}ï¼‰`, 2600);
      }
    }
  }

  function resetBoard() {
    cancelAiTurn();
    clearArmedCell();
    clearLastMoveMarker();
    hideGameOverOverlay();
    history.length = 0;
    gameOver = false;
    currentPlayer = BLACK;

    for (let idx = 0; idx < BOARD_SIZE * BOARD_SIZE; idx += 1) {
      setStone(idx, EMPTY, false);
    }

    const centerA = BOARD_SIZE / 2 - 1;
    const centerB = BOARD_SIZE / 2;
    setStone(toIndex(centerA, centerA), WHITE, false);
    setStone(toIndex(centerA, centerB), BLACK, false);
    setStone(toIndex(centerB, centerA), BLACK, false);
    setStone(toIndex(centerB, centerB), WHITE, false);

    invalidateLegalCache();
    settleTurn({ silentPassToast: true });
  }

  function fitBoard() {
    const cs = getComputedStyle(boardShellEl);
    const padX = parseFloat(cs.paddingLeft) + parseFloat(cs.paddingRight);
    const padY = parseFloat(cs.paddingTop) + parseFloat(cs.paddingBottom);
    const maxWidth = boardShellEl.clientWidth - padX;
    const maxHeight = boardShellEl.clientHeight - padY;
    const boardSize = Math.floor(Math.max(0, Math.min(maxWidth, maxHeight)));

    boardEl.style.width = `${boardSize}px`;
    boardEl.style.height = `${boardSize}px`;

    const boardCs = getComputedStyle(boardEl);
    const borderW = parseFloat(boardCs.borderLeftWidth || 0) + parseFloat(boardCs.borderRightWidth || 0);
    const cellSize = (boardSize - borderW) / BOARD_SIZE || 1;
    boardEl.style.setProperty("--cell-size", `${cellSize}px`);

    const coarsePointer = window.matchMedia("(pointer: coarse)").matches;
    precisionTapMode = coarsePointer && cellSize < 18;
    precisionNoteEl.classList.toggle("hidden", !precisionTapMode);

    if (!precisionTapMode) {
      clearArmedCell();
    }
  }

  function handleBoardClick(event) {
    const cell = event.target.closest(".cell");
    if (!cell) {
      return;
    }

    if (gameOver || aiThinking) {
      return;
    }

    if (mode === "ai" && currentPlayer === WHITE) {
      return;
    }

    const idx = Number(cell.dataset.idx);
    if (!Number.isInteger(idx)) {
      return;
    }

    const legalMoves = ensureLegalMoves();
    if (!legalMoves.has(idx)) {
      clearArmedCell();
      return;
    }

    if (precisionTapMode) {
      if (armedCell !== idx) {
        armCell(idx);
        showToast("ã‚‚ã†ä¸€åº¦ã‚¿ãƒƒãƒ—ã§ç€æ‰‹");
        return;
      }
      clearArmedCell();
    }

    applyMove(idx);
  }

  function applyModeUI() {
    for (const tab of modeTabs) {
      tab.classList.toggle("active", tab.dataset.mode === mode);
    }
    aiWrapEl.classList.toggle("hidden", mode !== "ai");
  }

  function applyAiLevelUI() {
    for (const button of levelTabs) {
      button.classList.toggle("active", Number(button.dataset.level) === aiLevel);
    }
  }

  function handleModeChange(nextMode) {
    if (nextMode === mode) {
      return;
    }
    mode = nextMode;
    applyModeUI();
    resetBoard();
    showToast(mode === "ai" ? "AIå¯¾æˆ¦ãƒ¢ãƒ¼ãƒ‰" : "ã‚ªã‚»ãƒ­ç›¤ãƒ¢ãƒ¼ãƒ‰");
  }

  function initEvents() {
    boardEl.addEventListener("click", handleBoardClick);

    modeTabs.forEach((tab) => {
      tab.addEventListener("click", () => {
        handleModeChange(tab.dataset.mode);
      });
    });

    levelTabs.forEach((button) => {
      button.addEventListener("click", () => {
        const nextLevel = Number(button.dataset.level);
        if (!Number.isInteger(nextLevel) || nextLevel < 1 || nextLevel > 3) {
          return;
        }
        aiLevel = nextLevel;
        applyAiLevelUI();
        if (mode === "ai") {
          showToast(`AIé›£æ˜“åº¦: ${button.textContent}`);
        }
      });
    });

    undoBtn.addEventListener("click", undoMove);
    newGameBtn.addEventListener("click", () => {
      resetBoard();
      showToast("æ–°ã—ã„ã‚²ãƒ¼ãƒ ã‚’é–‹å§‹ã—ã¾ã—ãŸ");
    });

    gameOverBtn.addEventListener("click", () => {
      resetBoard();
      showToast("æ–°ã—ã„ã‚²ãƒ¼ãƒ ã‚’é–‹å§‹ã—ã¾ã—ãŸ");
    });
    shareResultBtn.addEventListener("click", shareResultOnX);
    saveBoardBtn.addEventListener("click", downloadBoardSnapshot);

    window.addEventListener("resize", () => {
      if (resizeRaf) {
        cancelAnimationFrame(resizeRaf);
      }
      resizeRaf = requestAnimationFrame(() => {
        fitBoard();
        resizeRaf = null;
      });
    });
  }

  function init() {
    buildBoardDOM();
    placeStarPoints();
    applyModeUI();
    applyAiLevelUI();
    initEvents();
    fitBoard();
    resetBoard();
  }

  init();
})();
</script>
</body>
</html>
