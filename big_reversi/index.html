<!doctype html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>巨大オセロ｜32×32マスの巨大なリバーシ</title>
<meta name="description" content="巨大なオセロ（リバーシ）を無料で遊べるWebアプリ。通常の8×8を超える32×32マスの超巨大盤面で、AI対戦・対人戦が楽しめます。ブラウザで今すぐプレイ！" />
<meta name="author" content="Yuki Lab" />
<link rel="canonical" href="https://yuki-lab.com/big_reversi/" />

<!-- Open Graph -->
<meta property="og:type" content="website" />
<meta property="og:title" content="巨大オセロ｜32×32マスの巨大リバーシ" />
<meta property="og:description" content="巨大なオセロ（リバーシ）を無料で遊べるWebアプリ。通常の8×8を超える32×32マスの超巨大盤面で、AI対戦・対人戦が楽しめます。今すぐプレイ！" />
<meta property="og:url" content="https://yuki-lab.com/big_reversi/" />
<meta property="og:site_name" content="Yuki Lab" />
<meta property="og:locale" content="ja_JP" />

<!-- Twitter Card -->
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="巨大リバーシ - 32×32マスの巨大なオセロゲーム" />
<meta name="twitter:description" content="32×32マスの巨大オセロ（巨大リバーシ）をブラウザで無料プレイ。AI対戦・対人戦対応！" />

<!-- Favicon -->
<link rel="apple-touch-icon" type="image/png" href="../image/icon/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" sizes="16x16" href="../image/icon/icon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../image/icon/icon-32x32.png">
<link rel="icon" type="image/png" sizes="48x48" href="../image/icon/icon-48x48.png">

<style>
:root {
  --bg-deep: #0b1e10;
  --bg-mid: #132a18;
  --panel-bg: #1a2e1f;
  --panel-border: rgba(255, 255, 255, 0.08);
  --board: #0e7a1a;
  --board-dark: #0a6414;
  --line: #0a6414;
  --text: #e8f0e6;
  --text-dim: rgba(232, 240, 230, 0.55);
  --accent: #36c644;
  --accent-dim: rgba(74, 222, 128, 0.15);
  --stone-white-a: #fff;
  --stone-white-b: #b3b3b3;
  --last-move: #ef4444;
  --star: rgba(0, 0, 0, 0.5);
}

* { box-sizing: border-box; margin: 0; }

html, body {
  height: 100%;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Hiragino Sans', 'Noto Sans JP', sans-serif;
  color: var(--text);
  background: var(--bg-deep);
  background-image:
    radial-gradient(ellipse at 20% 0%, rgba(30, 80, 40, 0.5) 0%, transparent 60%),
    radial-gradient(ellipse at 80% 100%, rgba(20, 60, 30, 0.3) 0%, transparent 50%);
}

/* ── Layout ── */
.app {
  height: 100dvh;
  max-width: 960px;
  margin: 0 auto;
  padding: 10px 12px 12px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

/* ── Top Panel ── */
.top-panel {
  background: var(--panel-bg);
  border: 1px solid var(--panel-border);
  border-radius: 14px;
  padding: 12px 14px;
  box-shadow:
    0 1px 0 rgba(255,255,255,0.04) inset,
    0 8px 24px rgba(0, 0, 0, 0.35);
}

.title-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  flex-wrap: wrap;
}

.title {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Hiragino Sans', 'Noto Sans JP', sans-serif;
  font-size: clamp(1.1rem, 1.6vw + 0.5rem, 1.5rem);
  font-weight: 400;
  letter-spacing: 0.02em;
  color: var(--text);
}

/* ── Tabs & Pills ── */
.mode-tabs,
.level-tabs {
  display: inline-flex;
  background: rgba(255, 255, 255, 0.06);
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: 999px;
  padding: 3px;
  gap: 2px;
}

.tab,
.level-btn {
  appearance: none;
  border: none;
  background: transparent;
  color: var(--text-dim);
  border-radius: 999px;
  padding: 6px 13px;
  font-family: inherit;
  font-size: 0.82rem;
  font-weight: 500;
  line-height: 1;
  cursor: pointer;
  touch-action: manipulation;
  transition: color 0.15s, background 0.15s, box-shadow 0.15s;
}

.tab:hover,
.level-btn:hover {
  color: var(--text);
  background: rgba(255, 255, 255, 0.05);
}

.tab.active,
.level-btn.active {
  background: rgba(255, 255, 255, 0.12);
  color: var(--text);
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
}

/* ── Settings Row ── */
.settings-row {
  margin-top: 10px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  flex-wrap: wrap;
}

.ai-wrap {
  display: flex;
  align-items: center;
  gap: 8px;
}

.ai-wrap.hidden { display: none; }

.ai-label {
  font-size: 0.8rem;
  color: var(--text-dim);
  letter-spacing: 0.03em;
  text-transform: uppercase;
  font-weight: 500;
}

/* ── Action Buttons ── */
.actions {
  display: flex;
  gap: 6px;
}

.action-btn {
  appearance: none;
  border: 1px solid rgba(255, 255, 255, 0.1);
  background: rgba(255, 255, 255, 0.06);
  color: var(--text);
  border-radius: 999px;
  padding: 6px 14px;
  font-family: inherit;
  font-size: 0.82rem;
  font-weight: 500;
  line-height: 1;
  cursor: pointer;
  touch-action: manipulation;
  transition: background 0.15s, border-color 0.15s;
}

.action-btn:hover {
  background: rgba(255, 255, 255, 0.1);
  border-color: rgba(255, 255, 255, 0.18);
}

.action-btn:active {
  background: rgba(255, 255, 255, 0.14);
}

.action-btn:disabled {
  opacity: 0.35;
  cursor: not-allowed;
}

.action-btn.primary {
  background: rgba(74, 222, 128, 0.15);
  border-color: rgba(74, 222, 128, 0.25);
  color: var(--accent);
}

.action-btn.primary:hover {
  background: rgba(74, 222, 128, 0.22);
  border-color: rgba(74, 222, 128, 0.35);
}

/* ── HUD Row ── */
.hud-row {
  display: flex;
  flex-direction: column;
  gap: 8px;
  background: var(--panel-bg);
  border: 1px solid var(--panel-border);
  border-radius: 14px;
  padding: 10px 14px;
  box-shadow:
    0 1px 0 rgba(255,255,255,0.04) inset,
    0 8px 24px rgba(0, 0, 0, 0.35);
  flex-shrink: 0;
}

.hud-info {
  display: grid;
  grid-template-columns: 1fr auto 1fr;
  align-items: center;
  gap: 10px;
}

.turn-badge {
  display: flex;
  align-items: center;
  gap: 6px;
  font-weight: 700;
  font-size: 0.9rem;
}

.turn-stone {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  flex-shrink: 0;
}

.turn-stone.black {
  background:
    radial-gradient(circle at 36% 30%, rgba(255,255,255,0.10) 0%, transparent 28%),
    radial-gradient(ellipse at 40% 35%, #3a3a3a 0%, #181818 45%, #0e0e0e 80%, #080808 100%);
  box-shadow: 0 0 0 1px rgba(255,255,255,0.08);
}

.turn-stone.white {
  background: radial-gradient(circle at 35% 30%, #fff 0%, #d0d0d0 70%);
  box-shadow: 0 0 0 1px rgba(0,0,0,0.15);
}

/* ── Score Display ── */
.score-area {
  width: 100%;
}

.score-counts {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 5px;
  font-variant-numeric: tabular-nums;
  font-weight: 700;
  font-size: 0.88rem;
}

.score-disc {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  flex-shrink: 0;
}

.score-disc.black {
  background:
    radial-gradient(circle at 36% 30%, rgba(255,255,255,0.10) 0%, transparent 28%),
    radial-gradient(ellipse at 40% 35%, #3a3a3a 0%, #181818 45%, #0e0e0e 80%, #080808 100%);
  box-shadow: 0 0 0 1px rgba(255,255,255,0.08);
}

.score-disc.white {
  background: radial-gradient(circle at 35% 30%, #fff, #d0d0d0);
  box-shadow: 0 0 0 1px rgba(0,0,0,0.15);
}

.score-num {
  min-width: 22px;
  text-align: center;
}

.score-sep {
  color: var(--text-dim);
  margin: 0 2px;
  font-weight: 400;
}

.score-bar {
  height: 6px;
  border-radius: 3px;
  background: rgba(255, 255, 255, 0.08);
  overflow: hidden;
  display: flex;
}

.score-bar-black {
  background: #333;
  height: 100%;
  transition: width 0.4s ease;
  border-radius: 2px 0 0 2px;
}

.score-bar-white {
  background: #e0e0e0;
  height: 100%;
  transition: width 0.4s ease;
  border-radius: 0 2px 2px 0;
}

.state {
  font-size: 0.8rem;
  color: var(--text-dim);
  white-space: nowrap;
  text-align: right;
  justify-self: end;
}

/* ── Precision Note ── */
.precision-note {
  margin: 8px 0 0;
  padding: 6px 10px;
  border-radius: 8px;
  background: var(--accent-dim);
  font-size: 0.78rem;
  color: var(--accent);
  border: 1px solid rgba(74, 222, 128, 0.12);
}

.precision-note.hidden { display: none; }

/* ── Board Shell ── */
.board-shell {
  flex: 1;
  min-height: 0;
  position: relative;
  background: rgba(255, 255, 255, 0.03);
  border-radius: 16px;
  border: 1px solid rgba(255, 255, 255, 0.06);
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 8px;
}

/* ── Board ── */
.board {
  --cell-size: 14px;
  position: relative;
  display: grid;
  aspect-ratio: 1 / 1;
  max-width: 100%;
  max-height: 100%;
  grid-template-columns: repeat(32, minmax(0, 1fr));
  grid-template-rows: repeat(32, minmax(0, 1fr));
  border-radius: 8px;
  overflow: hidden;
  border: 2px solid rgba(0, 0, 0, 0.4);
  background-color: var(--board);
  background-image:
    linear-gradient(135deg, rgba(255,255,255,0.04) 0%, transparent 50%, rgba(0,0,0,0.06) 100%);
  box-shadow:
    inset 0 1px 3px rgba(0, 0, 0, 0.25),
    inset 0 -1px 2px rgba(255, 255, 255, 0.05),
    0 4px 16px rgba(0, 0, 0, 0.3);
}

/* ── Cells ── */
.cell {
  appearance: none;
  -webkit-appearance: none;
  display: block;
  position: relative;
  border: none;
  margin: 0;
  padding: 0;
  background: transparent;
  box-shadow: inset -1px -1px 0 var(--line);
  cursor: pointer;
  touch-action: manipulation;
  overflow: hidden;
}

.cell:focus-visible {
  outline: 2px solid rgba(255, 255, 255, 0.85);
  outline-offset: -2px;
  z-index: 3;
}

.cell.armed {
  outline: 2px solid rgba(255, 215, 0, 0.95);
  outline-offset: -2px;
  z-index: 3;
}

.cell.legal {
  background: #1ba12a;
}

.cell.legal:hover {
  background: #1cad2d;
}

/* ── Star Points ── */
.star-point {
  position: absolute;
  width: 3px;
  height: 3px;
  border-radius: 50%;
  background: var(--star);
  pointer-events: none;
  z-index: 1;
  transform: translate(-50%, -50%);
}

/* ── Stones ── */
.stone,
.hint {
  position: absolute;
  width: 78%;
  height: 78%;
  border-radius: 50%;
  top: calc(50% - 0.5px);
  left: calc(50% - 0.5px);
  transform: translate(-50%, -50%);
}

.stone {
  z-index: 2;
}

.stone.black {
  background: radial-gradient(circle at 34% 28%, #292929 0, #0a0a0a 100%);
  box-shadow:
    0 1px 2px rgba(0, 0, 0, 0.5);
}

.stone.white {
  background: radial-gradient(circle at 34% 28%, var(--stone-white-a) 0, var(--stone-white-b) 100%);
  box-shadow:
    0 1px 2px rgba(0, 0, 0, 0.2);
}

.stone.pop {
  animation: piece-pop 0.15s ease-out;
}

/* ── Last Move Marker ── */
.last-move-marker {
  position: absolute;
  width: 3px;
  height: 3px;
  background: var(--last-move);
  top: calc(50% - 0.5px);
  left: calc(50% - 0.5px);
  transform: translate(-50%, -50%);
  z-index: 4;
  pointer-events: none;
}

/* ── Hints ── */
.hint {
  z-index: 1;
  opacity: 0.5;
  width: 1px;
  height: 1px;
}

.hint.black { background: #000; }
.hint.white { background: #fff; }

/* ── Game Over Overlay ── */
.game-over-overlay {
  position: absolute;
  inset: 0;
  border-radius: 16px;
  background: rgba(11, 30, 16, 0.82);
  backdrop-filter: blur(3px);
  -webkit-backdrop-filter: blur(3px);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 12px;
  z-index: 10;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s ease;
}

.game-over-overlay.visible {
  opacity: 1;
  pointer-events: auto;
}

.game-over-title {
  font-size: clamp(1.3rem, 3vw, 2rem);
  font-weight: 400;
  color: var(--text);
  text-align: center;
}

.game-over-score {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: clamp(1rem, 2vw, 1.3rem);
  font-weight: 700;
  font-variant-numeric: tabular-nums;
}

.game-over-disc {
  width: 18px;
  height: 18px;
  border-radius: 50%;
}

.game-over-disc.black {
  background: radial-gradient(circle at 35% 30%, #555, #111);
  box-shadow: 0 0 0 1px rgba(255,255,255,0.15);
}

.game-over-disc.white {
  background: radial-gradient(circle at 35% 30%, #fff, #ccc);
  box-shadow: 0 0 0 1px rgba(0,0,0,0.15);
}

.game-over-sep {
  color: var(--text-dim);
  font-weight: 400;
}

.game-over-btn {
  appearance: none;
  border: 1px solid rgba(74, 222, 128, 0.3);
  background: rgba(74, 222, 128, 0.15);
  color: var(--accent);
  border-radius: 999px;
  padding: 9px 22px;
  font-family: inherit;
  font-size: 0.88rem;
  font-weight: 600;
  cursor: pointer;
  transition: background 0.15s;
  margin-top: 4px;
}

.game-over-btn:hover {
  background: rgba(74, 222, 128, 0.25);
}

/* ── Toast ── */
.toast {
  position: fixed;
  left: 50%;
  bottom: 18px;
  transform: translate(-50%, 14px);
  padding: 9px 13px;
  border-radius: 999px;
  color: #f5fff4;
  background: rgba(15, 28, 16, 0.9);
  border: 1px solid rgba(255, 255, 255, 0.18);
  box-shadow: 0 6px 20px rgba(0, 0, 0, 0.36);
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.2s ease, transform 0.2s ease;
  font-size: 0.85rem;
  z-index: 20;
}

.toast.show {
  opacity: 1;
  transform: translate(-50%, 0);
}

@keyframes piece-pop {
  from { transform: translate(-50%, -50%) scale(0); }
  to { transform: translate(-50%, -50%) scale(1); }
}

/* ── Responsive ── */
@media (max-width: 599px) {
  .app {
    padding: 6px 6px 8px;
    gap: 6px;
  }

  .top-panel {
    padding: 10px;
  }

  .tab,
  .level-btn {
    padding: 5px 10px;
    font-size: 0.78rem;
  }

  .action-btn {
    padding: 5px 10px;
    font-size: 0.78rem;
  }

  .state {
    font-size: 0.76rem;
  }

  .board-shell {
    padding: 4px;
  }

  .hud-row {
    gap: 6px;
    padding: 8px 10px;
  }

  .hud-info {
    gap: 6px;
  }

  .game-over-overlay {
    border-radius: 14px;
  }

  .star-point {
    width: 4px;
    height: 4px;
  }
}

/* ── Footer ── */
.site-footer {
  text-align: center;
  padding: 10px 14px 14px;
  font-size: 0.78rem;
  color: var(--text-dim);
  line-height: 1.6;
  flex-shrink: 0;
}

.site-footer a {
  color: var(--accent);
  text-decoration: none;
  font-weight: 500;
  transition: color 0.15s;
}

.site-footer a:hover {
  text-decoration: underline;
  color: #6ee7a0;
}

.footer-divider {
  display: inline-block;
  width: 28px;
  height: 1px;
  background: rgba(255, 255, 255, 0.1);
  vertical-align: middle;
  margin: 0 6px;
}


</style>
</head>
<body>
<div class="app">
  <section class="top-panel">
    <div class="title-row">
      <h1 class="title">巨大オセロ</h1>
      <div class="mode-tabs" role="tablist" aria-label="対戦モード">
        <button type="button" class="tab" data-mode="pvp">対人戦</button>
        <button type="button" class="tab active" data-mode="ai">AI対戦</button>
      </div>
    </div>
    <div class="settings-row">
      <div class="ai-wrap" id="aiWrap">
        <span class="ai-label">AI難易度</span>
        <div class="level-tabs" role="group" aria-label="AI難易度">
          <button type="button" class="level-btn" data-level="1">初級</button>
          <button type="button" class="level-btn active" data-level="2">中級</button>
          <button type="button" class="level-btn" data-level="3">上級</button>
        </div>
      </div>
      <div class="actions">
        <button type="button" class="action-btn primary" id="newGameBtn">新規ゲーム</button>
        <button type="button" class="action-btn" id="undoBtn">一手戻す</button>
      </div>
    </div>
    <p class="precision-note hidden" id="precisionNote">セルが小さいため、誤タッチ防止で「2回タップ」で着手します。</p>
  </section>
  <section class="board-shell" id="boardShell">
    <div class="board" id="board" role="grid" aria-label="32x32 オセロ盤"></div>
    <div class="game-over-overlay" id="gameOverOverlay">
      <div class="game-over-title" id="gameOverTitle">ゲーム終了</div>
      <div class="game-over-score" id="gameOverScore">
        <span class="game-over-disc black"></span>
        <span id="goBlack">2</span>
        <span class="game-over-sep">—</span>
        <span id="goWhite">2</span>
        <span class="game-over-disc white"></span>
      </div>
      <button type="button" class="game-over-btn" id="gameOverBtn">新規ゲーム</button>
    </div>
  </section>
  <section class="hud-row">
    <div class="hud-info">
      <div class="turn-badge" id="turnBadge">
        <span class="turn-stone black"></span>
        <span>手番: 黒</span>
      </div>
      <div class="score-counts" id="scoreLine">
        <span class="score-disc black"></span>
        <span class="score-num" id="blackCount">2</span>
        <span class="score-sep">—</span>
        <span class="score-num" id="whiteCount">2</span>
        <span class="score-disc white"></span>
      </div>
      <div class="state" id="stateLine">合法手 4</div>
    </div>
    <div class="score-area" id="scoreArea">
      <div class="score-bar">
        <div class="score-bar-black" id="scoreBarBlack" style="width:50%"></div>
        <div class="score-bar-white" id="scoreBarWhite" style="width:50%"></div>
      </div>
    </div>
  </section>
</div>
<footer class="site-footer">
  制作：Yuki Lab | 人気オセロサイト <a href="https://reversi.yuki-lab.com" target="_blank" rel="noopener">リバーシWeb</a> の一周年記念スピンオフ作品です<br>
</footer>
<div class="toast" id="toast" role="status" aria-live="polite"></div>

<script>
(() => {
  "use strict";

  const BOARD_SIZE = 32;
  const EMPTY = 0;
  const BLACK = 1;
  const WHITE = 2;
  const DIRECTIONS = [
    [-1, -1], [-1, 0], [-1, 1],
    [0, -1],           [0, 1],
    [1, -1],  [1, 0],  [1, 1]
  ];

  // Star point positions for 32x32 (like Go board reference points)
  const STAR_POINTS = [
    [8, 8], [8, 16], [8, 24],
    [16, 8], [16, 16], [16, 24],
    [24, 8], [24, 16], [24, 24]
  ];

  const boardEl = document.getElementById("board");
  const boardShellEl = document.getElementById("boardShell");
  const turnBadgeEl = document.getElementById("turnBadge");
  const stateLineEl = document.getElementById("stateLine");
  const toastEl = document.getElementById("toast");
  const undoBtn = document.getElementById("undoBtn");
  const newGameBtn = document.getElementById("newGameBtn");
  const precisionNoteEl = document.getElementById("precisionNote");
  const aiWrapEl = document.getElementById("aiWrap");
  const modeTabs = Array.from(document.querySelectorAll(".tab"));
  const levelTabs = Array.from(document.querySelectorAll(".level-btn"));

  // Score elements
  const blackCountEl = document.getElementById("blackCount");
  const whiteCountEl = document.getElementById("whiteCount");
  const scoreBarBlackEl = document.getElementById("scoreBarBlack");
  const scoreBarWhiteEl = document.getElementById("scoreBarWhite");

  // Game over elements
  const gameOverOverlay = document.getElementById("gameOverOverlay");
  const gameOverTitle = document.getElementById("gameOverTitle");
  const goBlackEl = document.getElementById("goBlack");
  const goWhiteEl = document.getElementById("goWhite");
  const gameOverBtn = document.getElementById("gameOverBtn");

  const cellEls = new Array(BOARD_SIZE * BOARD_SIZE);
  const stoneEls = new Array(BOARD_SIZE * BOARD_SIZE).fill(null);
  const hintEls = new Array(BOARD_SIZE * BOARD_SIZE).fill(null);
  const board = Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(EMPTY));

  let mode = "ai";
  let aiLevel = 2;
  let currentPlayer = BLACK;
  let gameOver = false;
  let aiThinking = false;
  let aiTimer = null;
  let toastTimer = null;
  let legalCachePlayer = null;
  let legalMovesCache = new Map();
  let highlighted = new Set();
  let armedCell = null;
  let precisionTapMode = false;
  let resizeRaf = null;
  let lastMoveIdx = null;
  let lastMoveMarkerEl = null;

  const history = [];

  const toIndex = (row, col) => row * BOARD_SIZE + col;
  const rowOf = (idx) => Math.floor(idx / BOARD_SIZE);
  const colOf = (idx) => idx % BOARD_SIZE;
  const inBounds = (row, col) => row >= 0 && row < BOARD_SIZE && col >= 0 && col < BOARD_SIZE;
  const opposite = (player) => (player === BLACK ? WHITE : BLACK);
  const colorName = (player) => (player === BLACK ? "黒" : "白");

  function showToast(message, duration = 1600) {
    toastEl.textContent = message;
    toastEl.classList.add("show");
    if (toastTimer) {
      clearTimeout(toastTimer);
    }
    toastTimer = setTimeout(() => {
      toastEl.classList.remove("show");
      toastTimer = null;
    }, duration);
  }

  function cancelAiTurn() {
    if (aiTimer) {
      clearTimeout(aiTimer);
      aiTimer = null;
    }
    aiThinking = false;
  }

  function invalidateLegalCache() {
    legalCachePlayer = null;
    legalMovesCache = new Map();
  }

  function buildBoardDOM() {
    const fragment = document.createDocumentFragment();
    for (let idx = 0; idx < BOARD_SIZE * BOARD_SIZE; idx += 1) {
      const cell = document.createElement("button");
      cell.type = "button";
      cell.className = "cell";
      cell.dataset.idx = String(idx);
      cell.setAttribute("role", "gridcell");
      fragment.appendChild(cell);
      cellEls[idx] = cell;
    }
    boardEl.appendChild(fragment);
  }

  function placeStarPoints() {
    for (const [row, col] of STAR_POINTS) {
      const dot = document.createElement("div");
      dot.className = "star-point";
      dot.style.left = `${(col / BOARD_SIZE) * 99.8}%`;
      dot.style.top = `${(row / BOARD_SIZE) * 99.8}%`;
      boardEl.appendChild(dot);
    }
  }

  function clearArmedCell() {
    if (armedCell !== null) {
      cellEls[armedCell].classList.remove("armed");
      armedCell = null;
    }
  }

  function armCell(idx) {
    if (armedCell === idx) {
      return;
    }
    clearArmedCell();
    armedCell = idx;
    cellEls[idx].classList.add("armed");
  }

  function clearLastMoveMarker() {
    if (lastMoveMarkerEl) {
      lastMoveMarkerEl.remove();
      lastMoveMarkerEl = null;
    }
    lastMoveIdx = null;
  }

  function setLastMoveMarker(idx) {
    clearLastMoveMarker();
    lastMoveIdx = idx;
    const marker = document.createElement("div");
    marker.className = "last-move-marker";
    cellEls[idx].appendChild(marker);
    lastMoveMarkerEl = marker;
  }

  function setStone(idx, value, animate = false) {
    const row = rowOf(idx);
    const col = colOf(idx);
    board[row][col] = value;

    const cell = cellEls[idx];
    let stone = stoneEls[idx];

    if (value === EMPTY) {
      if (stone) {
        stone.remove();
        stoneEls[idx] = null;
      }
      return;
    }

    if (!stone) {
      stone = document.createElement("div");
      stone.className = "stone";
      cell.appendChild(stone);
      stoneEls[idx] = stone;
    }

    stone.classList.toggle("black", value === BLACK);
    stone.classList.toggle("white", value === WHITE);

    if (animate) {
      stone.classList.remove("pop");
      void stone.offsetWidth;
      stone.classList.add("pop");
    }
  }

  function updateHighlights(moves) {
    const next = new Set(moves.keys());

    for (const idx of highlighted) {
      if (next.has(idx)) {
        continue;
      }
      if (hintEls[idx]) {
        hintEls[idx].remove();
        hintEls[idx] = null;
      }
      cellEls[idx].classList.remove("legal");
    }

    for (const idx of next) {
      if (!hintEls[idx]) {
        const hint = document.createElement("div");
        hint.className = "hint";
        cellEls[idx].appendChild(hint);
        hintEls[idx] = hint;
      }
      hintEls[idx].classList.toggle("black", currentPlayer === BLACK);
      hintEls[idx].classList.toggle("white", currentPlayer === WHITE);
      cellEls[idx].classList.add("legal");
    }

    highlighted = next;
  }

  function hasAnyFlip(index, player, boardRef = board) {
    const row = rowOf(index);
    const col = colOf(index);

    if (boardRef[row][col] !== EMPTY) {
      return false;
    }

    const enemy = opposite(player);

    for (const [dr, dc] of DIRECTIONS) {
      let r = row + dr;
      let c = col + dc;
      let seenEnemy = false;

      while (inBounds(r, c) && boardRef[r][c] === enemy) {
        seenEnemy = true;
        r += dr;
        c += dc;
      }

      if (seenEnemy && inBounds(r, c) && boardRef[r][c] === player) {
        return true;
      }
    }

    return false;
  }

  function collectFlips(index, player, boardRef = board) {
    const row = rowOf(index);
    const col = colOf(index);

    if (boardRef[row][col] !== EMPTY) {
      return [];
    }

    const enemy = opposite(player);
    const flips = [];

    for (const [dr, dc] of DIRECTIONS) {
      let r = row + dr;
      let c = col + dc;
      const line = [];

      while (inBounds(r, c) && boardRef[r][c] === enemy) {
        line.push(toIndex(r, c));
        r += dr;
        c += dc;
      }

      if (line.length > 0 && inBounds(r, c) && boardRef[r][c] === player) {
        flips.push(...line);
      }
    }

    return flips;
  }

  function computeLegalMoves(player, boardRef = board) {
    const moves = new Map();
    for (let row = 0; row < BOARD_SIZE; row += 1) {
      for (let col = 0; col < BOARD_SIZE; col += 1) {
        if (boardRef[row][col] !== EMPTY) {
          continue;
        }
        const idx = toIndex(row, col);
        const flips = collectFlips(idx, player, boardRef);
        if (flips.length > 0) {
          moves.set(idx, flips);
        }
      }
    }
    return moves;
  }

  function computeLegalMoveCount(player, boardRef = board) {
    let count = 0;
    for (let row = 0; row < BOARD_SIZE; row += 1) {
      for (let col = 0; col < BOARD_SIZE; col += 1) {
        if (boardRef[row][col] !== EMPTY) {
          continue;
        }
        if (hasAnyFlip(toIndex(row, col), player, boardRef)) {
          count += 1;
        }
      }
    }
    return count;
  }

  function ensureLegalMoves() {
    if (legalCachePlayer === currentPlayer) {
      return legalMovesCache;
    }
    legalMovesCache = computeLegalMoves(currentPlayer);
    legalCachePlayer = currentPlayer;
    return legalMovesCache;
  }

  function countPieces() {
    let black = 0;
    let white = 0;
    let empty = 0;

    for (let row = 0; row < BOARD_SIZE; row += 1) {
      for (let col = 0; col < BOARD_SIZE; col += 1) {
        const value = board[row][col];
        if (value === BLACK) {
          black += 1;
        } else if (value === WHITE) {
          white += 1;
        } else {
          empty += 1;
        }
      }
    }

    return { black, white, empty };
  }

  function updateScoreBar(counts) {
    const total = counts.black + counts.white;
    if (total === 0) {
      scoreBarBlackEl.style.width = "50%";
      scoreBarWhiteEl.style.width = "50%";
    } else {
      const blackPct = (counts.black / total) * 100;
      const whitePct = (counts.white / total) * 100;
      scoreBarBlackEl.style.width = `${blackPct}%`;
      scoreBarWhiteEl.style.width = `${whitePct}%`;
    }
  }

  function showGameOverOverlay(counts) {
    goBlackEl.textContent = counts.black;
    goWhiteEl.textContent = counts.white;

    if (counts.black === counts.white) {
      gameOverTitle.textContent = "引き分け";
    } else if (counts.black > counts.white) {
      gameOverTitle.textContent = "黒の勝ち";
    } else {
      gameOverTitle.textContent = "白の勝ち";
    }

    gameOverOverlay.classList.add("visible");
  }

  function hideGameOverOverlay() {
    gameOverOverlay.classList.remove("visible");
  }

  function updateStatus(legalCount = null) {
    const counts = countPieces();
    blackCountEl.textContent = counts.black;
    whiteCountEl.textContent = counts.white;
    updateScoreBar(counts);

    if (gameOver) {
      const turnStone = turnBadgeEl.querySelector(".turn-stone");
      turnStone.className = "turn-stone";
      turnBadgeEl.querySelector("span:last-child").textContent = "ゲーム終了";
      if (counts.black === counts.white) {
        stateLineEl.textContent = `引き分け`;
      } else if (counts.black > counts.white) {
        stateLineEl.textContent = `黒の勝ち`;
      } else {
        stateLineEl.textContent = `白の勝ち`;
      }
      undoBtn.disabled = history.length === 0;
      showGameOverOverlay(counts);
      return;
    }

    hideGameOverOverlay();

    const turnStone = turnBadgeEl.querySelector(".turn-stone");
    turnStone.classList.toggle("black", currentPlayer === BLACK);
    turnStone.classList.toggle("white", currentPlayer === WHITE);
    turnBadgeEl.querySelector("span:last-child").textContent = `手番: ${colorName(currentPlayer)}`;

    const moves = legalCount === null ? ensureLegalMoves().size : legalCount;
    if (aiThinking && mode === "ai" && currentPlayer === WHITE) {
      stateLineEl.textContent = `AIが考え中…（合法手 ${moves}）`;
    } else {
      stateLineEl.textContent = `合法手 ${moves}`;
    }

    undoBtn.disabled = history.length === 0;
  }

  function positionWeight(index) {
    const row = rowOf(index);
    const col = colOf(index);
    const last = BOARD_SIZE - 1;

    const top = row === 0;
    const bottom = row === last;
    const left = col === 0;
    const right = col === last;

    if ((top || bottom) && (left || right)) {
      return 170;
    }

    let score = 0;
    if (top || bottom || left || right) {
      score += 24;
    }

    const nearTop = row === 1;
    const nearBottom = row === last - 1;
    const nearLeft = col === 1;
    const nearRight = col === last - 1;

    if ((nearTop || nearBottom) && (left || right)) {
      score -= 36;
    }
    if ((nearLeft || nearRight) && (top || bottom)) {
      score -= 36;
    }
    if ((nearTop || nearBottom) && (nearLeft || nearRight)) {
      score -= 48;
    }

    const dist = Math.min(row, col, last - row, last - col);
    score += Math.min(dist, 6) * 2;

    return score;
  }

  function chooseAiMove(moves) {
    const entries = Array.from(moves.entries());
    if (entries.length === 0) {
      return null;
    }

    if (aiLevel === 1) {
      return entries[Math.floor(Math.random() * entries.length)][0];
    }

    const counts = countPieces();
    const lateGame = counts.empty < 180;

    if (aiLevel === 2) {
      const scored = entries.map(([idx, flips]) => ({
        idx,
        score: flips.length * (lateGame ? 4 : 2) + positionWeight(idx) * 0.5
      }));
      scored.sort((a, b) => b.score - a.score);
      // Pick randomly from top 40% of candidates (at least 2)
      const poolSize = Math.max(2, Math.ceil(scored.length * 0.4));
      const pool = scored.slice(0, poolSize);
      return pool[Math.floor(Math.random() * pool.length)].idx;
    }

    const quickScores = entries.map(([idx, flips]) => {
      const score = flips.length * (lateGame ? 6 : 3) + positionWeight(idx);
      return { idx, flips, score };
    });

    quickScores.sort((a, b) => b.score - a.score);
    const candidateCount = Math.min(8, quickScores.length);
    let best = quickScores[0];
    let bestFinalScore = -Infinity;

    for (let i = 0; i < candidateCount; i += 1) {
      const candidate = quickScores[i];
      const changed = [candidate.idx, ...candidate.flips];
      const previous = new Array(changed.length);

      for (let j = 0; j < changed.length; j += 1) {
        const index = changed[j];
        const row = rowOf(index);
        const col = colOf(index);
        previous[j] = board[row][col];
        board[row][col] = WHITE;
      }

      const opponentMoves = computeLegalMoveCount(BLACK);
      let finalScore = candidate.score - opponentMoves * 2.8;
      if (opponentMoves === 0) {
        finalScore += 120;
      }

      for (let j = 0; j < changed.length; j += 1) {
        const index = changed[j];
        const row = rowOf(index);
        const col = colOf(index);
        board[row][col] = previous[j];
      }

      if (finalScore > bestFinalScore) {
        bestFinalScore = finalScore;
        best = candidate;
      }
    }

    return best.idx;
  }

  function applyMove(index) {
    if (gameOver) {
      return;
    }

    const legalMoves = ensureLegalMoves();
    const flips = legalMoves.get(index);
    if (!flips) {
      return;
    }

    history.push({
      mover: currentPlayer,
      placed: index,
      flips: flips.slice()
    });

    setStone(index, currentPlayer, true);
    for (const flipIndex of flips) {
      setStone(flipIndex, currentPlayer, false);
    }

    setLastMoveMarker(index);

    currentPlayer = opposite(currentPlayer);
    invalidateLegalCache();
    settleTurn();
  }

  function revertRecord(record) {
    setStone(record.placed, EMPTY, false);
    const rollbackColor = opposite(record.mover);
    for (const idx of record.flips) {
      setStone(idx, rollbackColor, false);
    }
    currentPlayer = record.mover;
    gameOver = false;
    invalidateLegalCache();
  }

  function undoMove() {
    if (history.length === 0) {
      return;
    }

    cancelAiTurn();
    clearArmedCell();

    let undoSteps = 1;
    if (mode === "ai" && currentPlayer === BLACK && history.length >= 2) {
      const latest = history[history.length - 1];
      if (latest.mover === WHITE) {
        undoSteps = 2;
      }
    }

    for (let i = 0; i < undoSteps; i += 1) {
      const record = history.pop();
      if (!record) {
        break;
      }
      revertRecord(record);
    }

    // Update last move marker to previous move
    clearLastMoveMarker();
    if (history.length > 0) {
      setLastMoveMarker(history[history.length - 1].placed);
    }

    settleTurn({ silentPassToast: true });
  }

  function settleTurn(options = {}) {
    const silentPassToast = Boolean(options.silentPassToast);
    clearArmedCell();
    cancelAiTurn();

    if (gameOver) {
      updateHighlights(new Map());
      updateStatus(0);
      return;
    }

    let passCount = 0;

    while (passCount < 2) {
      const moves = ensureLegalMoves();
      updateHighlights(moves);
      updateStatus(moves.size);

      if (moves.size > 0) {
        if (mode === "ai" && currentPlayer === WHITE) {
          aiThinking = true;
          updateStatus(moves.size);
          aiTimer = setTimeout(() => {
            aiTimer = null;
            aiThinking = false;

            if (mode !== "ai" || gameOver || currentPlayer !== WHITE) {
              updateStatus();
              return;
            }

            const cachedMoves = ensureLegalMoves();
            if (cachedMoves.size === 0) {
              settleTurn({ silentPassToast: true });
              return;
            }

            const aiChoice = chooseAiMove(cachedMoves);
            if (aiChoice !== null) {
              applyMove(aiChoice);
            }
          }, 300);
        }
        return;
      }

      const passed = currentPlayer;
      currentPlayer = opposite(currentPlayer);
      invalidateLegalCache();
      passCount += 1;

      if (passCount === 1 && !silentPassToast) {
        showToast(`${colorName(passed)}は置ける場所がないためパス`);
      }
    }

    gameOver = true;
    updateHighlights(new Map());
    updateStatus(0);

    const { black, white } = countPieces();
    if (!silentPassToast) {
      if (black === white) {
        showToast(`ゲーム終了: 引き分け（黒${black} - 白${white}）`, 2600);
      } else if (black > white) {
        showToast(`ゲーム終了: 黒の勝ち（黒${black} - 白${white}）`, 2600);
      } else {
        showToast(`ゲーム終了: 白の勝ち（黒${black} - 白${white}）`, 2600);
      }
    }
  }

  function resetBoard() {
    cancelAiTurn();
    clearArmedCell();
    clearLastMoveMarker();
    hideGameOverOverlay();
    history.length = 0;
    gameOver = false;
    currentPlayer = BLACK;

    for (let idx = 0; idx < BOARD_SIZE * BOARD_SIZE; idx += 1) {
      setStone(idx, EMPTY, false);
    }

    const centerA = BOARD_SIZE / 2 - 1;
    const centerB = BOARD_SIZE / 2;
    setStone(toIndex(centerA, centerA), WHITE, false);
    setStone(toIndex(centerA, centerB), BLACK, false);
    setStone(toIndex(centerB, centerA), BLACK, false);
    setStone(toIndex(centerB, centerB), WHITE, false);

    invalidateLegalCache();
    settleTurn({ silentPassToast: true });
  }

  function fitBoard() {
    const cs = getComputedStyle(boardShellEl);
    const padX = parseFloat(cs.paddingLeft) + parseFloat(cs.paddingRight);
    const padY = parseFloat(cs.paddingTop) + parseFloat(cs.paddingBottom);
    const maxWidth = boardShellEl.clientWidth - padX;
    const maxHeight = boardShellEl.clientHeight - padY;
    const boardSize = Math.floor(Math.max(0, Math.min(maxWidth, maxHeight)));

    boardEl.style.width = `${boardSize}px`;
    boardEl.style.height = `${boardSize}px`;

    const boardCs = getComputedStyle(boardEl);
    const borderW = parseFloat(boardCs.borderLeftWidth || 0) + parseFloat(boardCs.borderRightWidth || 0);
    const cellSize = (boardSize - borderW) / BOARD_SIZE || 1;
    boardEl.style.setProperty("--cell-size", `${cellSize}px`);

    const coarsePointer = window.matchMedia("(pointer: coarse)").matches;
    precisionTapMode = coarsePointer && cellSize < 18;
    precisionNoteEl.classList.toggle("hidden", !precisionTapMode);

    if (!precisionTapMode) {
      clearArmedCell();
    }
  }

  function handleBoardClick(event) {
    const cell = event.target.closest(".cell");
    if (!cell) {
      return;
    }

    if (gameOver || aiThinking) {
      return;
    }

    if (mode === "ai" && currentPlayer === WHITE) {
      return;
    }

    const idx = Number(cell.dataset.idx);
    if (!Number.isInteger(idx)) {
      return;
    }

    const legalMoves = ensureLegalMoves();
    if (!legalMoves.has(idx)) {
      clearArmedCell();
      return;
    }

    if (precisionTapMode) {
      if (armedCell !== idx) {
        armCell(idx);
        showToast("もう一度タップで着手");
        return;
      }
      clearArmedCell();
    }

    applyMove(idx);
  }

  function applyModeUI() {
    for (const tab of modeTabs) {
      tab.classList.toggle("active", tab.dataset.mode === mode);
    }
    aiWrapEl.classList.toggle("hidden", mode !== "ai");
  }

  function applyAiLevelUI() {
    for (const button of levelTabs) {
      button.classList.toggle("active", Number(button.dataset.level) === aiLevel);
    }
  }

  function handleModeChange(nextMode) {
    if (nextMode === mode) {
      return;
    }
    mode = nextMode;
    applyModeUI();
    resetBoard();
    showToast(mode === "ai" ? "AI対戦モード" : "対人戦モード");
  }

  function initEvents() {
    boardEl.addEventListener("click", handleBoardClick);

    modeTabs.forEach((tab) => {
      tab.addEventListener("click", () => {
        handleModeChange(tab.dataset.mode);
      });
    });

    levelTabs.forEach((button) => {
      button.addEventListener("click", () => {
        const nextLevel = Number(button.dataset.level);
        if (!Number.isInteger(nextLevel) || nextLevel < 1 || nextLevel > 3) {
          return;
        }
        aiLevel = nextLevel;
        applyAiLevelUI();
        if (mode === "ai") {
          showToast(`AI難易度: ${button.textContent}`);
        }
      });
    });

    undoBtn.addEventListener("click", undoMove);
    newGameBtn.addEventListener("click", () => {
      resetBoard();
      showToast("新しいゲームを開始しました");
    });

    gameOverBtn.addEventListener("click", () => {
      resetBoard();
      showToast("新しいゲームを開始しました");
    });

    window.addEventListener("resize", () => {
      if (resizeRaf) {
        cancelAnimationFrame(resizeRaf);
      }
      resizeRaf = requestAnimationFrame(() => {
        fitBoard();
        resizeRaf = null;
      });
    });
  }

  function init() {
    buildBoardDOM();
    placeStarPoints();
    applyModeUI();
    applyAiLevelUI();
    initEvents();
    fitBoard();
    resetBoard();
  }

  init();
})();
</script>
</body>
</html>
